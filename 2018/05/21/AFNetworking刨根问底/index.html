<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>AFNetworking刨根问底 | Lotheve&#39;s</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="火车慢慢停下&lt;br&gt;这又是一个全新的地方">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="AFNetworking刨根问底 | Lotheve&#39;s">
    <meta name="twitter:description" content="火车慢慢停下&lt;br&gt;这又是一个全新的地方">

    <meta property="og:type" content="article">
    <meta property="og:title" content="AFNetworking刨根问底 | Lotheve&#39;s">
    <meta property="og:description" content="火车慢慢停下&lt;br&gt;这又是一个全新的地方">

    
    <meta name="author" content="Lotheve">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar.jpeg">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Lotheve&#39;s" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2018/05/21/AFNetworking刨根问底/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Lotheve&#39;s 的主页"><img src="/images/avatar.jpg" width="80" alt="Lotheve&#39;s logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Lotheve&#39;s">Lotheve&#39;s</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">菩提本无树 明镜亦非台</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">火车慢慢停下<br>这又是一个全新的地方</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
              <li class="navigation__item"><a href="/story">时光机</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.cn/onlychacha" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/Lotheve" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-05-21T15:53:48.000Z" class="post-list__meta--date date">2018-05-21</time> &#8226; <span class="post-meta__tags tags">于&nbsp; </span>
      <span class="page-pv">
      &nbsp;阅读&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">AFNetworking刨根问底</h1>
  </header>

  <section class="post">
    <p><img src="http://oubmw34rc.bkt.clouddn.com/blog/AF/afnetworking-logo.png" alt=""></p>
<p>AFNetworking网络框架在iOS开发中的霸主地位已经根深蒂固，本篇将基于3.2.1版本对框架的几个核心模块做一波分析。首先对于框架整体的架构，简单归纳如下：</p>
<p><img src="http://oubmw34rc.bkt.clouddn.com/blog/AF/afnetworking1.png" alt=""></p>
<h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><h4 id="模块概要"><a href="#模块概要" class="headerlink" title="模块概要"></a>模块概要</h4><p>AFURLSessionManager是AF最核心的模块，用来创建请求的task实体。每个manager都维护了一个NSURLSession对象及其配置，用来创建task。对外开放了若干创建task对象的接口（包括DataTask、DownloadTask、UploadTask）以及设置回调方法的接口，整体功能并不复杂。关于该模块的内容，我决定以问答的形式进行展开，读者可以在自行阅读源码的基础上，结合这几个问题的分析来理解。</p>
<h4 id="session和task是一对多的关系，如何将task的回调方法保存下来？"><a href="#session和task是一对多的关系，如何将task的回调方法保存下来？" class="headerlink" title="session和task是一对多的关系，如何将task的回调方法保存下来？"></a>session和task是一对多的关系，如何将task的回调方法保存下来？</h4><p>我们知道，一个session可以创建多个task，一个sessionManager维护一个session，因此sessionManager和task是一对多的关系。sessionManager类提供了创建task的接口，接口支持定制task的上/下行进度、请求落地的回调，例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler;</div></pre></td></tr></table></figure>
<p>既然是一对多的关系，sessionManager内部必然要将task的回调方法保存起来，以便在task请求的过程中调用，从而能够实现定制每个task的回调。那么内部是怎么实现的呢？</p>
<p>AFURLSessionManager的实现文件主要包含了两个类：AFURLSessionManagerTaskDelegate 和 AFURLSessionManager。AFURLSessionManager每创建一个task，就会创建一个对应的AFURLSessionManagerTaskDelegate对象，并将两者关系对应起来维护在一个字典中。这两个类都履行了作为请求回调代理对象的职责，只不过，AFURLSessionManager是session级别的，只要是当前session下的task，都会回调AFURLSessionManager中的代理方法，如果只是这样，回调就不能细化到task级别，这就很鸡肋了。毕竟在实际业务中，不同的请求的回调处理逻辑大相径庭。而AFURLSessionManagerTaskDelegate的存在则是为了定制task级别的回调，主要涉及4个请求过程相关的回调：上行进度、下行进度、请求落地以及文件下载完成，这些回调block在每次创建task的时候都由上层传进来（不传默认为nil），然后创建一个专门的delegate对象来持有这个task的回调方法，因为task和delegate对象是一一对应的，因此这个task的回调方式就被保存下来了。</p>
<p>以下行进度为例，任意一个请求，当请求接收到数据，AFURLSessionManager的 <code>URLSession: dataTask: didReceiveData:</code> 都会收到回调通知，不过这个方法里只能处理session级别的回调逻辑，要对应到task级别，操作就是找到task对应的AFURLSessionManagerTaskDelegate对象，将消息转发给该对象的 <code>URLSession: dataTask: didReceiveData:</code> 方法。因为delegate对象存有对应task的下行回调方法，这样一来，就能够将下行进度的回调细化到task级别了。下面是AFURLSessionManager接收请求数据的代理方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 取出task对应的delegate，将消息转发给delegate对象，从而将回调细化到task级别</span></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</div><div class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</div><div class="line">    <span class="comment">// session级别的回调逻辑</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveData) &#123;</div><div class="line">        <span class="keyword">self</span>.dataTaskDidReceiveData(session, dataTask, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以AFURLSessionManagerTaskDelegate的存在，就是为了上层能够定制task主要的几个回调。</p>
<h4 id="涉及的线程？"><a href="#涉及的线程？" class="headerlink" title="涉及的线程？"></a>涉及的线程？</h4><ol>
<li><p><strong>请求在哪个线程发起？</strong></p>
<p>这个问题无法回答具体在哪个线程发起。每创建一个线程，都会分配一块固定大小的栈内存（512K），另外线程的切换也有开销，因此发请求这一操作是由系统根据当前cpu及内存的状态，决定在哪个线程执行，以及是否需要创建新的线程来执行的。</p>
</li>
<li><p><strong>请求的内部回调在哪里执行？</strong></p>
<p>指的是AFURLSessionManager中的NSURLSessionDelegate 、NSURLSessionTaskDelegate 等一系列协议中的回调方法在哪个线程执行。这些回调的执行位置取决于创建session的时候，指定的delegateQueue：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.operationQueue = [[NSOperationQueue alloc] init];</div><div class="line">self.operationQueue.maxConcurrentOperationCount = 1;</div><div class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>官方对于delegateQueue参数的说明如下：</p>
<blockquote>
<p>An operation queue for scheduling the delegate calls and completion handlers. The queue should be a serial queue, in order to ensure the correct ordering of callbacks. If nil, the session creates a serial operation queue for performing all delegate method calls and completion handler calls.</p>
</blockquote>
<p>根据描述，delegateQueue必须是一个串行队列，目的是为了使回调方法顺序执行。如何理解这个顺序执行？例如 <code>URLSession: dataTask: didReceiveData:</code> 方法，一个请求过程可能会回调多次，必须得保证这多个回调是时序的，否则进度回调就会有问题。如若使用并发队列，就无法保证时序了。AF里使用了一个自定义队列，并设置最大并发数为1，这就相当于是一个串行队列了。因此，请求的回调是在非主线程的线程中顺序执行的。若是将operationQueue设置为 <code>[NSOperationQueue mainQueue]</code> ，那就是在主线程中执行了。</p>
</li>
<li><p><strong>请求对外回调在哪里执行？</strong></p>
<p>首先要说的是，对外回调，主要涉及4个回调，申明在AFURLSessionManagerTaskDelegate 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock;</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock;</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler;</div></pre></td></tr></table></figure>
<p>这里需要区分一下请求落地的回调和另外几个。在AFURLSessionManager的头文件中，可以看到开放了两个相关属性：completionQueue、completionGroup ，前者是用来指定回调队列的，后者用来指定关联的group，不过这两个属性是给请求落地的回调（也就是completionHandler）用的。代码如下（仅保留了主要代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// AFURLSessionManagerTaskDelegate.m</div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line"> 	...</div><div class="line">    if (error) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line">        //若上层没有指定回调队列，则默认在主线程回调 </div><div class="line">        //若上层没有指定回调group，则默认使用内部的group</div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (self.completionHandler) &#123;</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line">		   //主线程发送通知</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        //异步并发调用 进行解析数据和对外回调</div><div class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</div><div class="line">            if (self.downloadFileURL) &#123;</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line">		   //回调方式同上</div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                if (self.completionHandler) &#123;</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError);</div><div class="line">                &#125;</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此结论是若上层没有指定回调队列，<strong>请求落地</strong>的回调默认在主线程执行。</p>
<p>而对于<strong>上行进度</strong>（uploadProgressBlock）和<strong>下行进度</strong>（downloadProgressBlock）的回调，则是另外的逻辑。首先要搞清楚上下行进度回调是怎么做到的？不清楚的童鞋请自行跳到下个Topic先。</p>
<p>现在假设你已经知道进度回调是借助KVO实现的了，进度回调的方法在KVO的代理方法中执行。那么问题就是KVO的代理方法在哪个线程执行了。答案是：<strong>监听的属性在哪个线程修改，就在哪个线程通知回调</strong>。很明显，属性是间接在请求的代理方法中修改的。之前讲过，代理方法是在非主线程的线程中执行的，因此，进度的回调，同样也是在非主线程执行的。实际业务中，可能经常会遇到监听上传请求进度更新进度条的UI操作，这时候就需要注意要在主线程执行这一操作了。<em>PS不解为何进度回调不设置成跟请求落地的回调一样，默认在主线程回调？</em></p>
<p>另外还有个下载完成的回调方法，也是间接在代理方法中调用的（读者可自行查阅代码），因此也在非主线程执行。</p>
</li>
</ol>
<p>####上下行进度回调的实现</p>
<p>AF中使用NSProgress表示请求的进度，AFURLSessionManagerTaskDelegate对象持有两个分别表示上行进度和下行进度的NSProgress对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSProgress *uploadProgress;</div><div class="line">@property (nonatomic, strong) NSProgress *downloadProgress;</div></pre></td></tr></table></figure>
<p>当回调进度相关的代理方法时，NSProgress对象的进度会发生更新。以上行进度为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//AFURLSessionManager.m</div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">   didSendBodyData:(int64_t)bytesSent</div><div class="line">    totalBytesSent:(int64_t)totalBytesSent</div><div class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend];</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到回调被转发给了task对应的delegate对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//AFURLSessionManagerTaskDelegate.m</div><div class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task</div><div class="line">   didSendBodyData:(int64_t)bytesSent</div><div class="line">    totalBytesSent:(int64_t)totalBytesSent</div><div class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123;</div><div class="line">    self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</div><div class="line">    self.uploadProgress.completedUnitCount = task.countOfBytesSent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>delegate对象做的事仅仅是更新了uploadProgress的totalUnitCount和completedUnitCount，这怎么就触发了上行进度回调方法的执行呢？相信你已经猜到了，没错就是KVO。delegate对象在创建的时候就注册了对NSProgress对象的fractionCompleted属性的监听:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[progress addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</div><div class="line">      		 options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div></pre></td></tr></table></figure>
<p>当completedUnitCount更新时，fractionCompleted在内部也会被更新，从而触发了KVO的代理方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</div><div class="line">   if ([object isEqual:self.downloadProgress]) &#123;</div><div class="line">        if (self.downloadProgressBlock) &#123;</div><div class="line">            self.downloadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</div><div class="line">        if (self.uploadProgressBlock) &#123;</div><div class="line">            self.uploadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见是在KVO的代理方法中执行进度回调方法的。</p>
<h2 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h2><p>AFHTTPSessionManager是AFURLSessionManager的子类，他的职能就是封装了包括GET、POST、PUT、HEAD等各种方式的请求接口，方便上层调用。其内部实现很简单，各个不同请求方式的接口，最终都调到同一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</div><div class="line">                                       URLString:(NSString *)URLString</div><div class="line">                                      parameters:(id)parameters</div><div class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</div><div class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</div><div class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</div><div class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</div><div class="line">&#123;</div><div class="line">    // 创建HTTP请求对象</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    // 调用下层的请求接口创建task对象</div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    dataTask = [self dataTaskWithRequest:request</div><div class="line">                          uploadProgress:uploadProgress</div><div class="line">                        downloadProgress:downloadProgress</div><div class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法就做了两件事：</p>
<ol>
<li>创建HTTP请求对象：使用requestSerializer创建请求对象，设置好请求方法，URL以及请求参数。requestSerializer是AFHTTPSessionManager的一个属性，用来创建HTTP请求对象（NSURLRequest），可以由上层指定类型，默认使用AFHTTPRequestSerializer，具体将在下节详细讲。另外还有个responseSerializer，是用来解析响应数据的，不过它是由AFURLSessionManager持有的，在AFURLSessionManagerTaskDelegate的处理请求完成的方法中可以见到它的身影。</li>
<li>调用下层的请求接口创建task对象：通过创建的request对象，调用下层的接口创建task对象然后返回。</li>
</ol>
<p>事实上也不是所有HTTP请求都会调到这个方法，唯一有区别的就是支持文件上传的的POST请求，因为其创建请求对象的方式有所不同，以及调用的下层接口也有所不同，所以单独拎出来处理。具体可以看这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(id)parameters</div><div class="line">     constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                      progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress</div><div class="line">                       success:(void (^)(NSURLSessionDataTask *task, id responseObject))success</div><div class="line">                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure;</div></pre></td></tr></table></figure>
<h2 id="AFURLRequestSerialization"><a href="#AFURLRequestSerialization" class="headerlink" title="AFURLRequestSerialization"></a>AFURLRequestSerialization</h2><h4 id="模块概要-1"><a href="#模块概要-1" class="headerlink" title="模块概要"></a>模块概要</h4><p>请求序列化器，上一节提到过这个类，AFHTTPSessionManager持有它，用来创建HTTP请求对象，因此笔者习惯称之为请求生成器。该类的实现文件有1400多行代码，比AFURLSessionManager还要长，但是它干的事却可以用一两句话来概括：<strong>用于创建完备的HTTP请求对象（NSURLRequest），包括设置好请求方式、请求头域、请求体，以及请求的一些配置，例如是否使用默认的cookie方案、是否支持蜂窝移动等。</strong>而之所以代码显得略长，主要是因为不同的表单数据编码类型的存在，需要一些复杂的操作，例如：表单数据由字典格式化为application/x-www-form-urlencoded格式的query串、multipart/form-data编码类型的表单请求的数据流格式化等。根据实现的差别主要分为三种请求对象：1.不含请求体的GET、HEAD、Delete请求；2.application/x-www-form-urlencoded编码类型的表单请求；3.multipart/form-data编码类型的表单请求。后面将对这3种类型的请求对象的创建流程进行讲解， 一些次要的辅助实现读者可自行阅读。</p>
<blockquote>
<p>对于不同表单编码类型的区别，参考 <a href="https://imququ.com/post/four-ways-to-post-data-in-http.html" target="_blank" rel="external">[四种常见的 POST 提交数据方式]</a></p>
</blockquote>
<p>这一模块主要涉及1个协议：AFURLRequestSerialization 和3个类：AFHTTPRequestSerializer 、AFJSONRequestSerializer、AFPropertyListRequestSerializer。关系如下：</p>
<p><img src="http://oubmw34rc.bkt.clouddn.com/blog/AF/afnetworking2.png" alt=""></p>
<ul>
<li><em>AFURLRequestSerialization</em>：协议，包含一个根据字典参数创建不同MIME类型请求的方法的申明。</li>
<li>AFHTTPRequestSerializer：默认的请求生成器，遵循AFURLRequestSerialization，提供默认的请求生成逻辑，包括创建不含请求体的GET、HEAD、DELETE请求 ，以及application/x-www-form-urlencoded编码类型的表单请求。</li>
<li>AFJSONRequestSerializer：AFHTTPRequestSerializer的子类，当表单数据需要使用application/json类型编码时使用。</li>
<li>AFPropertyListRequestSerializer：AFHTTPRequestSerializer的子类，当表单数据需要使用application/x-plist类型编码时使用。</li>
</ul>
<h4 id="不含请求体的GET、HEAD、Delete请求"><a href="#不含请求体的GET、HEAD、Delete请求" class="headerlink" title="不含请求体的GET、HEAD、Delete请求"></a>不含请求体的GET、HEAD、Delete请求</h4><p>我在阅读三方库源码的时候，一般都会先浏览一下头文件，大致拿捏一下文件结构以及各个类、方法的职责，以便找到一个合适的切入点。对于AFURLRequestSerialization来说，我的切入点就是<code>requestBySerializingRequest: withParameters:error:</code> 方法，因为AFURLRequestSerialization的职能就是创建请求对象，这个方法闻其名正中下怀，并且在AFHTTPSessionManager中就是通过这个方法创建请求对象的，可见该方法也是与外层交互的接口。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                                 URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                                     error:(<span class="built_in">NSError</span> *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</div><div class="line">	<span class="comment">//设置请求头</span></div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</div><div class="line">    mutableRequest.HTTPMethod = method;</div><div class="line">	<span class="comment">//设置请求配置</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</div><div class="line">            [mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</div><div class="line"></div><div class="line">	<span class="keyword">return</span> mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最直观的就是设置了请求方式及请求对象的一些配置。AFURLRequestSerialization开放了几个配置请求的属性，例如allowsCellularAccess（是否允许使用蜂窝移动 ) 、缓存策略（cachePolicy ）等，如果外层配置了相关属性，内部会记录该属性名到mutableObservedChangedKeyPaths数组中，创建请求对象的时候，根据该数组得知哪些属性配置过了，从而配置到请求中。</p>
<p>再者就是调用了 <code>requestBySerializingRequest:withParameters:</code> 方法，这就是那个协议申明的方法。来看看它在AFHTTPRequestSerializer中的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                               withParameters:(<span class="keyword">id</span>)parameters</div><div class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(request);</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</div><div class="line">	<span class="comment">//设置请求头域</span></div><div class="line">    [<span class="keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</div><div class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    <span class="comment">//请求参数格式化成application/x-www-form-urlencoded类型要求的格式                                   </span></div><div class="line">    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (parameters) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.queryStringSerialization) &#123;</div><div class="line">            <span class="built_in">NSError</span> *serializationError;</div><div class="line">            query = <span class="keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);</div><div class="line">            <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">                <span class="keyword">if</span> (error) &#123;</div><div class="line">                    *error = serializationError;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//key1=value1&amp;key2=value2&amp;... 会进行URL编码</span></div><div class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span>.queryStringSerializationStyle) &#123;</div><div class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</div><div class="line">                    query = AFQueryStringFromParameters(parameters);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//对于GET, HEAD, DELETE请求，将query参数拼接在URL中</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@"&amp;%@"</span> : <span class="string">@"?%@"</span>, query]];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!query) &#123;</div><div class="line">            query = <span class="string">@""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//其他方式的请求，需要把格式化后的表单数据设置到请求体中，并设置请求头域中的内容类型为application/x-www-form-urlencoded</span></div><div class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@"Content-Type"</span>]) &#123;</div><div class="line">            [mutableRequest setValue:<span class="string">@"application/x-www-form-urlencoded"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</div><div class="line">        &#125;</div><div class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，设置了请求头域。HTTPRequestHeaders数组中包含了两个默认的头域：Accept-Language 、User-Agent。接下来就是设置表单数据了，因为对于不含文件的表单请求，默认是使用application/x-www-form-urlencoded类型编码的，因此要先将表单数据格式化成以&amp;分割的键值对形式：key1=value1&amp;key2=value2&amp;…。之后要做的是将格式化后的表单数据设置到请求对象中。对于GET、HEAD、DELETE方式的请求，只要将表单数据拼接在URL上即可。</p>
<p>至此，一个完备的GET/HEAD/DELETE请求对象就创建好了，返回给外层使用即可。</p>
<h4 id="application-x-www-form-urlencoded编码类型的表单请求"><a href="#application-x-www-form-urlencoded编码类型的表单请求" class="headerlink" title="application/x-www-form-urlencoded编码类型的表单请求"></a>application/x-www-form-urlencoded编码类型的表单请求</h4><p>继续看上面的 <code>requestBySerializingRequest:withParameters:</code> 方法，对于非GET/HEAD/DELETE方式的请求，操作是将表单数据编码后设置到请求体中的，并设置内容类型为application/x-www-form-urlencoded类型。</p>
<p>需要注意的是：此处的表单数据是application/x-www-form-urlencoded类型的（key1=value1&amp;key2=value2&amp;…），所以指定”content-type”为application/x-www-form-urlencoded。如果是jSON格式的表单数据，即HTTPBody是参数字典通过NSJSONSerialization序列化得到的JSON数据，那么表单数据格式为JSON格式，则需要将”content-type”指定为application/json。AFJSONRequestSerializer就是做这个事的，作为AFHTTPRequestSerializer的子类，唯一的区别就是表单数据的编码类型不同，即”Content-Type”指定的类型不同；另外还有个AFPropertyListRequestSerializer，也是AFHTTPRequestSerializer的子类，当表单数据编码类型为application/x-plist的时候使用。</p>
<h4 id="multipart-form-data编码类型的表单请求"><a href="#multipart-form-data编码类型的表单请求" class="headerlink" title="multipart/form-data编码类型的表单请求"></a>multipart/form-data编码类型的表单请求</h4><p>除了支持上面两种类型的请求，还有一种比较特殊的表单请求，需要另外处理。这就是 multipart/form-data编码类型的表单请求，可以用来上传文件等数据流。在将AFHTTPSessionManager的时候提到过有一个比较特殊的支持文件上传的POST请求，其创建请求对象的方式和其他请求有所区别：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                    parameters:(<span class="keyword">id</span>)parameters</div><div class="line">     constructingBodyWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                      progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))uploadProgress</div><div class="line">                       success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> responseObject))success</div><div class="line">                       failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error))failure</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer multipartFormRequestWithMethod:<span class="string">@"POST"</span> URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError];</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到是通过 <code>multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock:</code> 方法创建的请求对象。从方法名可知该方法就是用来创建multipart/form-data编码类型的表单请求的。</p>
<blockquote>
<p>关于multipart/form-data，不了解的童鞋可以先参考<a href="https://www.jianshu.com/p/e810d1799384" target="_blank" rel="external">Multipart/form-data</a></p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableURLRequest</span> *)multipartFormRequestWithMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                                              URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                             parameters:(<span class="built_in">NSDictionary</span> *)parameters</div><div class="line">                              constructingBodyWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                                                  error:(<span class="built_in">NSError</span> *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [<span class="keyword">self</span> requestWithMethod:method URLString:URLString parameters:<span class="literal">nil</span> error:error];</div><div class="line">    __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">    <span class="comment">// 拼接非文件类型表单数据流</span></div><div class="line">    <span class="keyword">if</span> (parameters) &#123;</div><div class="line">        <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</div><div class="line">            <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</div><div class="line">            <span class="keyword">if</span> ([pair.value isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                data = pair.value;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([pair.value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</div><div class="line">                data = [<span class="built_in">NSData</span> data];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                data = [[pair.value description] dataUsingEncoding:<span class="keyword">self</span>.stringEncoding];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (data) &#123;</div><div class="line">                [formData appendPartWithFormData:data name:[pair.field description]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 拼接其他数据流，这个block是上层传入的，上层可以通过此block注入要上传的文件数据流或任何其他表单数据</span></div><div class="line">    <span class="keyword">if</span> (block) &#123;</div><div class="line">        block(formData);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 数据流拼接完毕后进行整理，设置请求对象到HTTPBodyStream中，设置"Content-Type"为"multipart/form-data",并计算数据长度，设置到"Content-Length"头域中</span></div><div class="line">    <span class="keyword">return</span> [formData requestByFinalizingMultipartFormData];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于multipart/form-data类型的表单处理，因为其数据格式较为复杂，而且要支持不同类型表单项的添加方法，因此相关源码占了较大的篇幅。不过主要的处理逻辑很简单，只是实现较为复杂。AFStreamingMultipartFormData这个类主要是用来封装表单数据流拼接相关操作的，首先是对字典项参数中的数据一一调用了 <code>appendPartWithFormData</code> 方法进行拼接，而后执行了一个外部传入的block，用来拼接外部的表单项，可能是文件、图片，也可能是简单的key-value键值对。最后，数据流拼接完毕后，再进行整理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestByFinalizingMultipartFormData &#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.bodyStream isEmpty]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.request;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.bodyStream setInitialAndFinalBoundaries];</div><div class="line">    [<span class="keyword">self</span>.request setHTTPBodyStream:<span class="keyword">self</span>.bodyStream];</div><div class="line">    [<span class="keyword">self</span>.request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"multipart/form-data; boundary=%@"</span>, <span class="keyword">self</span>.boundary] forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</div><div class="line">    [<span class="keyword">self</span>.request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%llu"</span>, [<span class="keyword">self</span>.bodyStream contentLength]] forHTTPHeaderField:<span class="string">@"Content-Length"</span>];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.request;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置数据流的上下边界，这样表单数据流就完全成型了，设置到HTTPBodyStream中。最后再设置请求头域中的内容类型以及内容宽度。至此，一个multipart/form-data表单类型的请求才算创建完毕，可以返回给外层使用了。</p>
<h4 id="自定义请求"><a href="#自定义请求" class="headerlink" title="自定义请求"></a>自定义请求</h4><p>AF仅提供了各种表单类型格式、JSON格式、以及plist格式的数据的上传，如果有需要可以自定义创建一个指定数据格式的请求序列化器，例如XML格式。相关操作只需要继承AFHTTPRequestSerializer，然后实现AFURLRequestSerialization 协议中申明的方法可以，具体可以参照AFJSONRequestSerializer。</p>
<h2 id="AFURLResponseSerialization"><a href="#AFURLResponseSerialization" class="headerlink" title="AFURLResponseSerialization"></a>AFURLResponseSerialization</h2><h4 id="模块概要-2"><a href="#模块概要-2" class="headerlink" title="模块概要"></a>模块概要</h4><p>响应序列化器，用来解析响应数据，由AFURLSessionManager持有，习惯称之为响应解析器。该模块代码结构直观上比AFURLRequestSerialization清晰很多，主要包含了几种不同类型的响应数据解析方式，包含：JSON、XML、Plist、image。另外还有一个协议，申明了一个用来执行数据解析的方法。类结构如下：</p>
<p><img src="http://oubmw34rc.bkt.clouddn.com/blog/AF/afnetworking3.png" alt=""></p>
<ul>
<li>AFURLResponseSerialization：协议，申明了解析响应数据的方法</li>
<li>AFHTTPResponseSerializer：响应解析器的基类，仅提供了校验响应MIME类型及状态码的方法，不进行数据解析</li>
<li>AFJSONResponseSerializer ：JSON解析器</li>
<li>AFXMLParserResponseSerializer ：XML解析器</li>
<li>AFPropertyListResponseSerializer ：Plist解析器</li>
<li>AFImageResponseSerializer ：Image解析器</li>
<li>AFCompoundResponseSerializer ：组合解析器，使用包含的多个解析器去碰撞解析，解析成功即可。</li>
</ul>
<p>下面以JSON类型数据解析为例，讲解一下解析的流程是怎么样的。</p>
<h5 id="AFJSONResponseSerializer"><a href="#AFJSONResponseSerializer" class="headerlink" title="AFJSONResponseSerializer"></a>AFJSONResponseSerializer</h5><p>在JSON解析器初始化方法中，指定了几种允许的MIME类型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"application/json"</span>, <span class="string">@"text/json"</span>, <span class="string">@"text/javascript"</span>, <span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>这是一个集合属性，用来指定期望接收的MIME类型，如果响应的数据类型不在集合范围内，会被认定为这是一个出错的请求。另外还有一个acceptableStatusCodes属性，用来指定期望的响应状态码，即若实际响应的状态码不在期望的范围内，同样会被认定为是一个出错的请求，错误信息会经过包装后传递给外层。默认期望的成功请求状态码为200-299，是在基类AFHTTPResponseSerializer中指定的。</p>
<p>外层使用时是通过调用 <code>responseObjectForResponse: data: error:</code> 来进行数据解析的，该方法就是协议AFURLResponseSerialization中申明的方法，因此若想自定义一种解析器，继承AFHTTPResponseSerializer ，实现该方法即可。AFJSONResponseSerializer中该方法的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</div><div class="line">                           data:(<span class="built_in">NSData</span> *)data</div><div class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    <span class="comment">//校验响应的内容类型及状态码 对于不符合期望的MIME类型的响应直接ruturn nil</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</div><div class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//JSON解析</span></div><div class="line">    <span class="built_in">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">" "</span> length:<span class="number">1</span>]];</div><div class="line">    <span class="keyword">if</span> (data.length == <span class="number">0</span> || isSpace) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">id</span> responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span>.readingOptions error:&amp;serializationError];</div><div class="line">    <span class="keyword">if</span> (!responseObject)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = AFErrorWithUnderlyingError(serializationError, *error);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//是否移除JSON对象中值为空的项</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removesKeysWithNullValues) &#123;</div><div class="line">        <span class="keyword">return</span> AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> responseObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>检查响应数据是否符合期望的MIME类型以及状态码</li>
<li>进行JSON解析</li>
<li>根据removesKeysWithNullValues属性决定是否移除JSON对象中值为空的项 </li>
<li>返回解析后的JSON对象</li>
</ol>
<p>AFURLSessionManager中使用解析器的地方是在NSURLSessionTaskDelegate的 <code>URLSession: task: didCompleteWithError:</code> 方法中，即请求落地后调用解析器的 <code>responseObjectForResponse: data: error:</code> 方法进行响应数据的解析，而后回调给上层。</p>
<h2 id="AFSecurityPolicy"><a href="#AFSecurityPolicy" class="headerlink" title="AFSecurityPolicy"></a>AFSecurityPolicy</h2><p>苹果一再强调HTTPs，虽然时至今日（2018.5）还是没有强制使用HTTPs，但是相信大多数APP都已经接入HTTPs了。AFSecurityPolicy是用来验证HTTPs证书的工具类，支持对CA证书及自签证书的验证方式进行配置。</p>
<p>主要包含3中验证策略：</p>
<ul>
<li>AFSSLPinningModeNone：表示不做SSL pinning，即不用证书绑定的方式验证，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是CA签发的就会通过，若是自签证书是无法通过的。 </li>
<li>AFSSLPinningModePublicKey：用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。 </li>
<li>AFSSLPinningModeCertificate：也是用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的有效性（包括签名/格式/域名/有效期等信息），第二步是对比本地证书与服务器证书是否一致。 </li>
</ul>
<p>AF中默认的验证策略是AFSSLPinningModeNone，对于这种策略网上很多资料都解释成不进行任何校验，这种说法完全就是误导人，它表示的只是不使用证书绑定的方式校验证书，因此这是一种当使用CA证书而非自签证书的时候使用的一种策略。</p>
<p>AFURLSessionManager中，是在请求的鉴权代理方法中进行证书验证的，具体有两处相关的回调的代理，分别是 <code>URLSession: didReceiveChallenge: completionHandler:</code> 和 <code>URLSession: task: didReceiveChallenge: completionHandler:</code> 。关于两者的区别，前者只在 challenge.protectionSpace.authenticationMethod 为下面4个中的一个时才会调用：</p>
<ul>
<li>NSURLAuthenticationMethodNTLM</li>
<li>NSURLAuthenticationMethodNegotiate</li>
<li>NSURLAuthenticationMethodClientCertificate</li>
<li>NSURLAuthenticationMethodServerTrust</li>
</ul>
<p>若前者未实现，则调用后者。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</div><div class="line">        credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">        <span class="keyword">if</span> (credential) &#123;</div><div class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>challenge表示一个认证的挑战对象，内含此次认证的所有信息。其属性protectionSpace保存了需要认证的保护空间，每个protectionSpace都保存了认证主机地址、端口、认证方法等重要信息。当认证方法为NSURLAuthenticationMethodServerTrust时，就会调用securityPolicy的方法进行认证。最后根据认证结果回调不同的disposition和disposition参数。</p>
<p>下面主要看核心的认证方法 <code>evaluateServerTrust: forDomain:</code> ，方法主要传入服务器认证对象及请求域名 :</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</div><div class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</div><div class="line">&#123;</div><div class="line">    <span class="comment">//1、不能隐式地信任自签证书？个人理解，对于不使用证书绑定的方式验证或者不提供绑定证书的情况，若设置了允许无效证书，即allowInvalidCertificates为YES，同时又要求验证域名，这种设置是不安全的的，直接返回NO。</span></div><div class="line">    <span class="comment">//此处不是很理解，望各路大神赐教！！</span></div><div class="line">    <span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"In order to validate a domain name for self signed certificates, you MUST use pinning."</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//2、设置校验策略。若需要校验域名，则根据域名创建一个校验策略；否则创建一个X509标准的校验策略，用来校验证书的有效性（不会核对域名）</span></div><div class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</div><div class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</div><div class="line">    &#125;</div><div class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</div><div class="line">    <span class="comment">//3、验证证书有效性</span></div><div class="line">    <span class="comment">//3.1、不使用绑定证书校验的情况，若允许无效证书则直接返回YES，否则返回校验CA证书的验证结果。</span></div><div class="line">    <span class="comment">//3.2、使用绑定证书校验的情况，若证书无效，并且不允许无效证书，则直接返回NO。</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//4、根据SSLPinningMode对服务器证书做校验</span></div><div class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</div><div class="line">        <span class="comment">//4.1、CA校验，代码不会执行到此处</span></div><div class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        <span class="comment">//4.2、绑定证书校验</span></div><div class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</div><div class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</div><div class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</div><div class="line">            &#125;</div><div class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</div><div class="line">            <span class="comment">//4.2.1、先校验证书的有效性</span></div><div class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//4.2.2、匹配本地证书与服务器证书，若本地有能够匹配上的证书，则校验通过</span></div><div class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//4.3、公钥校验，若本地证书中，有公钥是能够和服务器证书的公钥匹配的，则验证成功。</span></div><div class="line">        <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</div><div class="line">            <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</div><div class="line">            <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</div><div class="line">                    <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</div><div class="line">                        trustedPublicKeyCount += <span class="number">1</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>验证过程已经在代码中注解了，另外一个内部的方法实现例如获取证书中的公钥，有兴趣的读者可以自行阅读。此处仅根据个人理解做几点说明：</p>
<ol>
<li><p><strong>使用绑定证书校验，即校验自签证书时，为什么要先校验证书的有效性，再匹配本地证书与服务器证书是否完全一致？</strong></p>
<p>个人理解，证书校验一步校验的是证书的域名、有效期、证书格式、有效性（验签）等，但是即便本地不含与服务端一致的证书，只要有相同公钥的证书，就能使验签通过，另外域名、有效期等的校验，则与本地证书完全无关。因此要想完整地验证自签证书，就得先校验证书的域名、有效期、有效性等信息，然后再匹配本地是否有该证书，这样的验证逻辑才是最完备的。若没有前面一步，那证书即便过期了也能永久使用。</p>
</li>
<li><p><strong>公钥验证的使用场景？</strong></p>
<p>所谓公钥校验就是用本地证书中的公钥匹配服务器证书的公钥，若有能够匹配的公钥，则验证成功。这种验证方式是一种极简易的验证方式，好处是即便服务器证书过期了，客户端也无需更换证书，只要服务器在创建证书时依旧使用老证书的密钥对即可。</p>
</li>
<li><p><strong>是否有必要校验域名？</strong></p>
<p>答案是能校验则校验。校验域名能够有效避免中间人攻击，若不校验域名，中间人劫持了HTTPs请求，并做了转发，这时候如果不校验域名，只要中间人给客户端的是一张合法的CA颁发的证书，客户端将毫不知情。这种情况下若进行证书校验，客户端就会因为服务器证书（实际上是中间人给的证书）中的域名匹配不上而拒绝连接。不过，如果你的请求是某个域名的子域名，而使用根域名的证书，例如证书上的域名为google.com，而请求是mail.google.com，此时若校验域名是不通过的，因此只能忽略域名的校验。当然不差钱的话，含通配符域名的证书你值得拥有。</p>
</li>
<li><p><strong>自签证书是否安全？</strong></p>
<p>使用自签证书时，只要本地保存一份与服务器一致的证书即可，那么这种操作安全吗？答案是肯定的，所谓安全与否，主要是看能否避开中间人攻击。因为中间人无法拿到服务器私钥，因此是无法建立与客户端的TLS连接的（TLS连接过程中加密密钥的约定需要服务端的私钥）。</p>
</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>AFNetworking作为当前iOS开发中使用最为广泛的基于OC的网络库，基本是三方库中不可或缺的一员。整个库的架构很清晰，外围还有用来检测网络的Reachability模块，以及用来扩展各个组件网络功能的UIKit模块，因其都属于即插即用的模块，并非AF的核心，本篇不再对其进行讲解。实际项目中的网络框架，大多根据实际业务在AF的基础上进行二次封装，常用的功能像批量请求、单一请求的取消、文件上传等，可能都需要更为精简的封装，以降低业务层的使用门槛。</p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/10/23/实践CocoaPods库的制作/" title="实践CocoaPods库的制作">实践CocoaPods库的制作</a></h2>
                <p class="excerpt">
                
                
本篇内容基于 CocoaPods V1.6.0 实践公有库及私有库的制作

前言作为一名iOSer，我们知道CocoaPods的作用是帮助我们管理和维护代码仓库。在说具体的如何制作Pod仓库之前，需要先来了解一下Pods是如何从远端拉取代码的。
1~/.cocoapods/repos
 安装了Co
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-10-23T06:42:38.000Z" class="post-list__meta--date date">2018-10-23</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/iOS/">iOS</a>
</span><a class="btn-border-small" href="/2018/10/23/实践CocoaPods库的制作/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/10/10/WebViewJavascriptBridge源码剖析/" title="WebViewJavascriptBridge源码剖析">WebViewJavascriptBridge源码剖析</a></h2>
                <p class="excerpt">
                
                对于任意hybrid APP，不可避免进行native与web之间的交互。WebViewJavascriptBridge 就是一款用于实现原生端与web端无缝交互的三方库，应用广泛，支持UIWebView、WKWebView（iOS）以及WebView（OSX），原理一致，本文借助OC的UIWebV
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-10-10T11:25:05.000Z" class="post-list__meta--date date">2017-10-10</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;</span><a class="btn-border-small" href="/2017/10/10/WebViewJavascriptBridge源码剖析/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  
<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'lotheves'; 
      
  var disqus_identifier = '/2018/05/21/AFNetworking刨根问底/';
  var disqus_title = 'AFNetworking刨根问底';
  var disqus_url = 'http://yoursite.com/2018/05/21/AFNetworking刨根问底/';
  

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          //dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
          dsq.src = 'https://a.disquscdn.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


            <footer class="footer">
    <span class="footer__copyright">
        本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2018 - 本站使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题,
        由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
    </span>
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-104179898-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?625528118da5bf56aa02dc2a21537069";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
